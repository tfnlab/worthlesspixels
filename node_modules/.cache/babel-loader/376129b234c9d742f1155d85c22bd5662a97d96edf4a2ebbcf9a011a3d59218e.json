{"ast":null,"code":"import _objectWithoutProperties from \"/Users/armenmerikyan/Desktop/wd/tfnlab.com/metagascarnext/stage-presets-gltfjsx/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"args\", \"cellColor\", \"sectionColor\", \"cellSize\", \"sectionSize\", \"followCamera\", \"infiniteGrid\", \"fadeDistance\", \"fadeStrength\", \"cellThickness\", \"sectionThickness\", \"side\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { extend } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nvar GridMaterial = shaderMaterial({\n  cellSize: 0.5,\n  sectionSize: 1,\n  fadeDistance: 100,\n  fadeStrength: 1,\n  cellThickness: 0.5,\n  sectionThickness: 1,\n  cellColor: new THREE.Color(),\n  sectionColor: new THREE.Color(),\n  infiniteGrid: 0,\n  followCamera: 0\n}, \"varying vec3 worldPosition;\\n   uniform float fadeDistance;\\n   uniform float infiniteGrid;\\n   uniform float followCamera;\\n   void main() {\\n     vec3 pos = position.xzy * (1. + fadeDistance * infiniteGrid);\\n     pos.xz += (cameraPosition.xz * followCamera);\\n     worldPosition = pos;\\n     gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n   }\", \"varying vec3 worldPosition;\\n   uniform float cellSize;\\n   uniform float sectionSize;\\n   uniform vec3 cellColor;\\n   uniform vec3 sectionColor;\\n   uniform float fadeDistance;\\n   uniform float fadeStrength;\\n   uniform float cellThickness;\\n   uniform float sectionThickness;\\n   uniform float infiniteGrid;\\n   float getGrid(float size, float thickness) {\\n     vec2 r = worldPosition.xz / size;\\n     vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\\n     float line = min(grid.x, grid.y) + 1. - thickness;\\n     return 1.0 - min(line, 1.);\\n   }\\n   void main() {\\n     float g1 = getGrid(cellSize, cellThickness);\\n     float g2 = getGrid(sectionSize, sectionThickness);\\n     float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / fadeDistance, 1.);\\n     vec3 color = mix(cellColor, sectionColor, min(1.,sectionThickness * g2));\\n     gl_FragColor = vec4(color, (g1 + g2) * pow(d,fadeStrength));\\n     gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\\n     if (gl_FragColor.a <= 0.0) discard;\\n     #include <tonemapping_fragment>\\n     #include <encodings_fragment>\\n   }\");\nvar Grid = /*#__PURE__*/React.forwardRef(function (_ref, fRef) {\n  var args = _ref.args,\n    _ref$cellColor = _ref.cellColor,\n    cellColor = _ref$cellColor === void 0 ? '#000000' : _ref$cellColor,\n    _ref$sectionColor = _ref.sectionColor,\n    sectionColor = _ref$sectionColor === void 0 ? '#2080ff' : _ref$sectionColor,\n    _ref$cellSize = _ref.cellSize,\n    cellSize = _ref$cellSize === void 0 ? 0.5 : _ref$cellSize,\n    _ref$sectionSize = _ref.sectionSize,\n    sectionSize = _ref$sectionSize === void 0 ? 1 : _ref$sectionSize,\n    _ref$followCamera = _ref.followCamera,\n    followCamera = _ref$followCamera === void 0 ? false : _ref$followCamera,\n    _ref$infiniteGrid = _ref.infiniteGrid,\n    infiniteGrid = _ref$infiniteGrid === void 0 ? false : _ref$infiniteGrid,\n    _ref$fadeDistance = _ref.fadeDistance,\n    fadeDistance = _ref$fadeDistance === void 0 ? 100 : _ref$fadeDistance,\n    _ref$fadeStrength = _ref.fadeStrength,\n    fadeStrength = _ref$fadeStrength === void 0 ? 1 : _ref$fadeStrength,\n    _ref$cellThickness = _ref.cellThickness,\n    cellThickness = _ref$cellThickness === void 0 ? 0.5 : _ref$cellThickness,\n    _ref$sectionThickness = _ref.sectionThickness,\n    sectionThickness = _ref$sectionThickness === void 0 ? 1 : _ref$sectionThickness,\n    _ref$side = _ref.side,\n    side = _ref$side === void 0 ? THREE.BackSide : _ref$side,\n    props = _objectWithoutProperties(_ref, _excluded);\n  extend({\n    GridMaterial: GridMaterial\n  });\n  var uniforms1 = {\n    cellSize: cellSize,\n    sectionSize: sectionSize,\n    cellColor: cellColor,\n    sectionColor: sectionColor,\n    cellThickness: cellThickness,\n    sectionThickness: sectionThickness\n  };\n  var uniforms2 = {\n    fadeDistance: fadeDistance,\n    fadeStrength: fadeStrength,\n    infiniteGrid: infiniteGrid,\n    followCamera: followCamera\n  };\n  return /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: fRef,\n    frustumCulled: false\n  }, props), /*#__PURE__*/React.createElement(\"gridMaterial\", _extends({\n    transparent: true,\n    \"extensions-derivatives\": true,\n    side: side\n  }, uniforms1, uniforms2)), /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: args\n  }));\n});\nexport { Grid };","map":{"version":3,"names":["_extends","React","THREE","extend","shaderMaterial","GridMaterial","cellSize","sectionSize","fadeDistance","fadeStrength","cellThickness","sectionThickness","cellColor","Color","sectionColor","infiniteGrid","followCamera","Grid","forwardRef","fRef","args","side","BackSide","props","uniforms1","uniforms2","createElement","ref","frustumCulled","transparent"],"sources":["/Users/armenmerikyan/Desktop/wd/tfnlab.com/metagascarnext/stage-presets-gltfjsx/node_modules/@react-three/drei/core/Grid.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { extend } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\n\nconst GridMaterial = shaderMaterial({\n  cellSize: 0.5,\n  sectionSize: 1,\n  fadeDistance: 100,\n  fadeStrength: 1,\n  cellThickness: 0.5,\n  sectionThickness: 1,\n  cellColor: new THREE.Color(),\n  sectionColor: new THREE.Color(),\n  infiniteGrid: 0,\n  followCamera: 0\n}, `varying vec3 worldPosition;\n   uniform float fadeDistance;\n   uniform float infiniteGrid;\n   uniform float followCamera;\n   void main() {\n     vec3 pos = position.xzy * (1. + fadeDistance * infiniteGrid);\n     pos.xz += (cameraPosition.xz * followCamera);\n     worldPosition = pos;\n     gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n   }`, `varying vec3 worldPosition;\n   uniform float cellSize;\n   uniform float sectionSize;\n   uniform vec3 cellColor;\n   uniform vec3 sectionColor;\n   uniform float fadeDistance;\n   uniform float fadeStrength;\n   uniform float cellThickness;\n   uniform float sectionThickness;\n   uniform float infiniteGrid;\n   float getGrid(float size, float thickness) {\n     vec2 r = worldPosition.xz / size;\n     vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n     float line = min(grid.x, grid.y) + 1. - thickness;\n     return 1.0 - min(line, 1.);\n   }\n   void main() {\n     float g1 = getGrid(cellSize, cellThickness);\n     float g2 = getGrid(sectionSize, sectionThickness);\n     float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / fadeDistance, 1.);\n     vec3 color = mix(cellColor, sectionColor, min(1.,sectionThickness * g2));\n     gl_FragColor = vec4(color, (g1 + g2) * pow(d,fadeStrength));\n     gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\n     if (gl_FragColor.a <= 0.0) discard;\n     #include <tonemapping_fragment>\n     #include <encodings_fragment>\n   }`);\nconst Grid = /*#__PURE__*/React.forwardRef(({\n  args,\n  cellColor = '#000000',\n  sectionColor = '#2080ff',\n  cellSize = 0.5,\n  sectionSize = 1,\n  followCamera = false,\n  infiniteGrid = false,\n  fadeDistance = 100,\n  fadeStrength = 1,\n  cellThickness = 0.5,\n  sectionThickness = 1,\n  side = THREE.BackSide,\n  ...props\n}, fRef) => {\n  extend({\n    GridMaterial\n  });\n  const uniforms1 = {\n    cellSize,\n    sectionSize,\n    cellColor,\n    sectionColor,\n    cellThickness,\n    sectionThickness\n  };\n  const uniforms2 = {\n    fadeDistance,\n    fadeStrength,\n    infiniteGrid,\n    followCamera\n  };\n  return /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: fRef,\n    frustumCulled: false\n  }, props), /*#__PURE__*/React.createElement(\"gridMaterial\", _extends({\n    transparent: true,\n    \"extensions-derivatives\": true,\n    side: side\n  }, uniforms1, uniforms2)), /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: args\n  }));\n});\n\nexport { Grid };\n"],"mappings":";;AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,MAAM,QAAQ,oBAAoB;AAC3C,SAASC,cAAc,QAAQ,qBAAqB;AAEpD,IAAMC,YAAY,GAAGD,cAAc,CAAC;EAClCE,QAAQ,EAAE,GAAG;EACbC,WAAW,EAAE,CAAC;EACdC,YAAY,EAAE,GAAG;EACjBC,YAAY,EAAE,CAAC;EACfC,aAAa,EAAE,GAAG;EAClBC,gBAAgB,EAAE,CAAC;EACnBC,SAAS,EAAE,IAAIV,KAAK,CAACW,KAAK,EAAE;EAC5BC,YAAY,EAAE,IAAIZ,KAAK,CAACW,KAAK,EAAE;EAC/BE,YAAY,EAAE,CAAC;EACfC,YAAY,EAAE;AAChB,CAAC,g9CAmCK;AACN,IAAMC,IAAI,GAAG,aAAahB,KAAK,CAACiB,UAAU,CAAC,gBAcxCC,IAAI,EAAK;EAAA,IAbVC,IAAI,QAAJA,IAAI;IAAA,sBACJR,SAAS;IAATA,SAAS,+BAAG,SAAS;IAAA,yBACrBE,YAAY;IAAZA,YAAY,kCAAG,SAAS;IAAA,qBACxBR,QAAQ;IAARA,QAAQ,8BAAG,GAAG;IAAA,wBACdC,WAAW;IAAXA,WAAW,iCAAG,CAAC;IAAA,yBACfS,YAAY;IAAZA,YAAY,kCAAG,KAAK;IAAA,yBACpBD,YAAY;IAAZA,YAAY,kCAAG,KAAK;IAAA,yBACpBP,YAAY;IAAZA,YAAY,kCAAG,GAAG;IAAA,yBAClBC,YAAY;IAAZA,YAAY,kCAAG,CAAC;IAAA,0BAChBC,aAAa;IAAbA,aAAa,mCAAG,GAAG;IAAA,6BACnBC,gBAAgB;IAAhBA,gBAAgB,sCAAG,CAAC;IAAA,iBACpBU,IAAI;IAAJA,IAAI,0BAAGnB,KAAK,CAACoB,QAAQ;IAClBC,KAAK;EAERpB,MAAM,CAAC;IACLE,YAAY,EAAZA;EACF,CAAC,CAAC;EACF,IAAMmB,SAAS,GAAG;IAChBlB,QAAQ,EAARA,QAAQ;IACRC,WAAW,EAAXA,WAAW;IACXK,SAAS,EAATA,SAAS;IACTE,YAAY,EAAZA,YAAY;IACZJ,aAAa,EAAbA,aAAa;IACbC,gBAAgB,EAAhBA;EACF,CAAC;EACD,IAAMc,SAAS,GAAG;IAChBjB,YAAY,EAAZA,YAAY;IACZC,YAAY,EAAZA,YAAY;IACZM,YAAY,EAAZA,YAAY;IACZC,YAAY,EAAZA;EACF,CAAC;EACD,OAAO,aAAaf,KAAK,CAACyB,aAAa,CAAC,MAAM,EAAE1B,QAAQ,CAAC;IACvD2B,GAAG,EAAER,IAAI;IACTS,aAAa,EAAE;EACjB,CAAC,EAAEL,KAAK,CAAC,EAAE,aAAatB,KAAK,CAACyB,aAAa,CAAC,cAAc,EAAE1B,QAAQ,CAAC;IACnE6B,WAAW,EAAE,IAAI;IACjB,wBAAwB,EAAE,IAAI;IAC9BR,IAAI,EAAEA;EACR,CAAC,EAAEG,SAAS,EAAEC,SAAS,CAAC,CAAC,EAAE,aAAaxB,KAAK,CAACyB,aAAa,CAAC,eAAe,EAAE;IAC3EN,IAAI,EAAEA;EACR,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEF,SAASH,IAAI"},"metadata":{},"sourceType":"module","externalDependencies":[]}